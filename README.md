# SimpleCompileFramework

## 当前进度
- 词法分析器构建中。。。
- 以 ```ops``` 表 存储有穷自动机，改进了 ```_lex_op_ll1()```，统一了不同长度单词的词法分析方法。
- 还剩下 数字常量、字符串常量、'.'开头词未完成。
- 语义分析理论学习ing
- 词法分析器完成基本完成，字符串常量改进中。
- 语义分析器构建中。。。
## debug过程
- ```_lex_push_char(scf_lex_t* lex,scf_lex_char_t* c)```，是将c自己压入栈，将 c 压栈后不可以 free(c)，出入栈都会出现无法访问栈的问题。正确做法应该是将 c 指向 NULL，而不是清空 c 指向的内存空间。

## 词法分析分析器创新
- 支持c语言全部的操作符和关键字
- 数据类型增加了bool型、string型，整型保留int型，浮点型保留float型
- 支持自定义增加新操作符，通过增加```scf_lex.c```中```ops```表实现，```ops```是一个存储操作符状态机的线性表结构。
- 其每个状态机元素为***首字符不同的操作符状态机*** ```scf_lex_op_t```，
- ```char c``` 为操作符的首字符，在每个状态机元素中的 ```c``` 应当是```互异的```
- ```enum scf_lex_words t```存储首字符对应的操作符类型
- ```c1[2][2] 和 t1[2][2]``` 是逻辑上的二维表，用于 ***存放后续字符*** 和 后续连接起来所代表的 ***操作符类型***
- ```int n[2]``` 操作符的第二个字符最多有```n[1]```，后续操作符长度最长为```n[2]```。
    ```c 
    typedef struct
    {
        char c;
        enum scf_lex_words t;
        char  c1[2][2];
        enum scf_lex_words t1[2][2];
        int n[2];
    }scf_lex_op_t; 
    ```
    - 状态机工作方式为逐行检索，按ll1方式匹配，当```c[i][j]```不能匹配时，返回```t1[i][j-1]```。每行第一个字符都不匹配则返回  ```t```。
    - 下面展示了">"字符开头的操作符状态机，其支持的操作符最大长度为3，第二个字符有两种情况,其填表方式如下图所示，左边尖括号开头的操作符共有4个，分别是```<,<<,<<=,<=```其中长度大于1的操作符op逻辑结构如下，因此其对应的```c1 & t1```表如下所示，故按照下方代码生成的一个 ```scf_lex_op_t``` 标识的就是 ``` '<' ``` 开头的操作符状态机。
        |    op  |op[*][0]|op[*][1]|
        |--------|:------:|:-----:|
        |op[0][*]|  <<  | <<=  |
        |op[1][*]|  <=  |    |


        |    c1  |c1[*][0]|c[*][1]|
        |--------|:------:|:-----:|
        |c1[0][*]|   '<'  |  '='  |
        |c1[1][*]|   '='  |  '\0'  |
        
        |    t1  |t1[*][0]|t[*][1]|
        |--------|:------:|:-----:|
        |t1[0][*]|SCF_LEX_WORD_SHR|SCF_LEX_WORD_SHR_ASSIGN|
        |t1[1][*]|SCF_LEX_WORD_GE|  0  |

    ```c
        {
            '>',                // c
            SCF_LEX_WORD_RT,    // t
             {                  // c1[2][2]
                {'>','='},      
                {'='}
              },
            {                   //t1[2][2]
                {SCF_LEX_WORD_SHR,SCF_LEX_WORD_SHR_ASSIGN},
                {SCF_LEX_WORD_GE}
            },  
            {2,2}               //n[1][2]
        }
    ```
- 增加新的操作符时仅需要将上述方式构造的添加到```scf_lex.c```中```ops```末尾。
- 非法字符: "$"、"`"

"""_lex_op_ll1()"""

## 感谢
编译器框架设计参考了 [@闲聊代码](https://author.baidu.com/home?from=bjh_article&app_id=1683021426724988) 老师的 [《用 C 语言写一个真正的词法分析分析器》](https://baijiahao.baidu.com/s?id=1696288054374712822&wfr=spider&for=pc) 系列分享